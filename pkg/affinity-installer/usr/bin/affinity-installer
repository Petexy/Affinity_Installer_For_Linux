#!/usr/bin/env python3

import gi
import subprocess
import threading
import gettext
import locale
import os
import shutil
import shlex

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw, GLib, Gdk

# --- Localization Setup ---
APP_NAME = "affinity-installer"
LOCALE_DIR = "/usr/share/locale" 

# Set up the locale environment
try:
    locale.setlocale(locale.LC_ALL, '')
    lang, _ = locale.getlocale()
    if lang is None:
        lang = 'en'
except locale.Error:
    lang = 'en'

gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
gettext.textdomain(APP_NAME)
translation = gettext.translation(APP_NAME, LOCALE_DIR, languages=[lang], fallback=True)
translation.install()
_ = gettext.gettext
# --------------------------


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app)
        # App info and reset of potentially lost data
        self.set_title(_("Affinity Installer"))
        self.set_default_size(900, 300)
        self.progress_visible = False
        self.progress_data = ""
        self.install_started = False
        self.error_message = None
        self.current_product = "Affinity"

        # Main vertical box to hold header bar and content
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        # Add Adwaita header bar
        self.header_bar = Adw.HeaderBar()
        self.header_bar.set_title_widget(Adw.WindowTitle.new("", ""))
        main_box.append(self.header_bar)

        css_provider = Gtk.CssProvider()
        css = """
        headerbar {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
        .titlebar {
            background-color: transparent;
        }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Main horizontal box for content
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=20,
                       margin_top=20, margin_bottom=20, margin_start=20, margin_end=20)
        main_box.append(hbox)

        # Left vertical button group
        button_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        hbox.append(button_box)

        # A single button to start the installation process
        self.btn_install = Gtk.Button(label=_("Select Installer File"))
        self.btn_toggle_progress = Gtk.Button(label=_("Show progress"), sensitive=False)

        self.btn_install.set_margin_start(12)
        self.btn_install.set_margin_end(12)
        self.btn_install.set_vexpand(True)
        self.btn_install.add_css_class("suggested-action")

        self.btn_toggle_progress.set_margin_bottom(12)
        self.btn_toggle_progress.set_margin_start(12)
        self.btn_toggle_progress.set_margin_end(12)
        self.btn_toggle_progress.set_vexpand(True)

        self.btn_install.connect("clicked", self.on_install_clicked)
        self.btn_toggle_progress.connect("clicked", self.on_toggle_progress_clicked)

        button_box.append(self.btn_install)
        button_box.append(self.btn_toggle_progress)

        # Right side: output or instructions
        self.output_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        hbox.append(self.output_box)

        self.info_label = Gtk.Label()
        self.set_welcome_message()
        self.info_label.set_vexpand(True)
        self.info_label.set_hexpand(True)
        self.info_label.set_wrap(True)
        self.output_box.append(self.info_label)

        # Output text view inside a scrolled window within a frame
        self.output_buffer = Gtk.TextBuffer()
        self.output_textview = Gtk.TextView.new_with_buffer(self.output_buffer)
        self.output_textview.set_wrap_mode(Gtk.WrapMode.WORD)
        self.output_textview.set_editable(False)
        self.output_textview.set_cursor_visible(False)
        self.output_textview.set_monospace(True)
        self.output_textview.set_left_margin(10)
        self.output_textview.set_right_margin(10)
        self.output_textview.set_top_margin(5)
        self.output_textview.set_bottom_margin(5)

        # Create a scrolled window
        self.scrolled_window = Gtk.ScrolledWindow()
        self.scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.scrolled_window.set_child(self.output_textview)
        self.scrolled_window.set_hexpand(True)
        self.scrolled_window.set_vexpand(True)

        self.output_frame = Gtk.Frame()
        self.output_frame.set_child(self.scrolled_window)
        self.output_frame.set_hexpand(True)
        self.output_frame.set_vexpand(True)
        self.output_frame.set_visible(False)

        self.output_box.append(self.output_frame)

                # Info label (default message or in-progress/completion info)
        image_path = "/usr/share/icons/github.petexy.affinityinstaller.png"
        self.welcome_image = Gtk.Image()
        if os.path.exists(image_path):
            self.welcome_image.set_from_file(image_path)
        else:
            self.welcome_image.set_from_icon_name("view-refresh")
        self.welcome_image.set_pixel_size(125)
        self.welcome_image.set_margin_end(20)
        self.welcome_image.set_margin_start(40)
        self.output_box.append(self.welcome_image)

        # Connect to the close-request signal to prevent closing during installation
        self.connect("close-request", self.on_close_request)

    def on_close_request(self, *args):
        # Handle the close-request signal to prevent closing during installation
        if self.install_started:
            # Show a notification or dialog to inform the user
            dialog = Adw.MessageDialog(
                heading=_("Installation in Progress"),
                body=_("Please wait until the installation is complete before closing the application."),
                transient_for=self,
                modal=True
            )
            dialog.add_response("ok", _("OK"))
            dialog.set_default_response("ok")
            dialog.set_close_response("ok")
            dialog.present()
            return True  # Prevents the window from closing
        return False  # Allows the window to close

    def set_welcome_message(self):
        self.info_label.set_margin_top(-15)
        self.info_label.set_markup(
            '<span size="large" weight="bold">{}</span>\n\n{}'.format(
                _("Welcome to Affinity Installer!"),
                _("The app is created to help you with the installation of the Affinity suite for Linux.\nPlease make sure that you have downloaded the Affinity application .exe file before the installation.")
            )
        )

    def on_install_clicked(self, button):
        # Starts the file selection process
        self.create_file_chooser()

    def create_file_chooser(self):
        """Creates and shows a file chooser dialog."""
        title = _("Select Affinity .exe file")
        file_chooser = Gtk.FileChooserDialog(
            title=title,
            transient_for=self,
            modal=True,
            action=Gtk.FileChooserAction.OPEN
        )
        
        # Use add_buttons instead of add_button (deprecated)
        file_chooser.add_buttons(
            _("Cancel"), Gtk.ResponseType.CANCEL,
            _("Open"), Gtk.ResponseType.OK
        )
        
        file_filter = Gtk.FileFilter()
        file_filter.set_name(_("Affinity Installer (*.exe)"))
        file_filter.add_pattern("*.exe")
        
        # Use set_filter instead of add_filter (deprecated)
        file_chooser.set_filter(file_filter)
        
        # Connect the response signal
        file_chooser.connect("response", self.on_file_chooser_response)
        file_chooser.present()

    def on_file_chooser_response(self, dialog, response_id):
        """Handles file selection and starts the installation."""
        if response_id == Gtk.ResponseType.OK:
            # Use get_files() instead of get_file() (deprecated)
            files = dialog.get_files()
            if files and files.get_n_items() > 0:
                file = files.get_item(0)
                exe_file_path = file.get_path()
                self.begin_install(exe_file_path)
            else:
                self.show_error_message(_("No file selected. Installation cancelled."))
        else:
            self.show_error_message(_("Installation cancelled."))
        
        dialog.destroy()

    def show_error_message(self, message):
        self.info_label.set_markup(
            f'<span color="red" weight="bold">{message}</span>'
        )
        self.info_label.set_visible(True)

    def begin_install(self, exe_path):
        self.install_started = True
        self.header_bar.set_sensitive(False)
        self.header_bar.set_opacity(0.5)
        self.btn_install.set_sensitive(False)
        self.btn_toggle_progress.set_sensitive(True)
        self.error_message = None

        # Fixed the problematic line
        install_message = _("Installing {}... This may take a while...").format(self.current_product)
        self.info_label.set_markup(f'<span size="xx-large" weight="bold">{install_message}</span>')
        
        self.output_frame.set_visible(False)
        self.info_label.set_visible(True)
        self.progress_data = ""
        self.progress_visible = False
        self.btn_toggle_progress.set_label(_("Show progress"))
        self.output_buffer.set_text("")

        self.run_installation_flow(exe_path)

    def on_toggle_progress_clicked(self, button):
        self.progress_visible = not self.progress_visible

        if self.progress_visible:
            self.btn_toggle_progress.set_label(_("Hide progress"))
            self.output_buffer.set_text(self.progress_data or _("[console output]"))
            self.output_frame.set_visible(True)
            self.info_label.set_visible(False)
            GLib.idle_add(self.scroll_to_end)
        else:
            self.btn_toggle_progress.set_label(_("Show progress"))
            self.output_frame.set_visible(False)
            self.info_label.set_label(_("Installing {}...").format(self.current_product))
            self.info_label.set_visible(True)

    def run_installation_flow(self, exe_path):
        def stream_output():
            try:
                # Helper to run a non-interactive command and stream its output for the log
                def run_and_log(command, fail_msg):
                    process = subprocess.Popen(
                        command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                        text=True, encoding='utf-8', errors='replace'
                    )
                    for line in iter(process.stdout.readline, ''):
                        if line:
                            self.progress_data += line
                            GLib.idle_add(self.update_output_buffer, self.progress_data)
                    process.stdout.close()
                    return_code = process.wait()
                    if return_code != 0:
                        raise subprocess.CalledProcessError(return_code, command, output=fail_msg)
                    return True

                # --- 1. Pacman Command ---
                self.progress_data += _("Step 1: Updating and installing wine-affinity...\n\n")
                GLib.idle_add(self.update_output_buffer, self.progress_data)
                pacman_cmd = "run0 pacman -Syu wine-affinity --noconfirm && chmod 775 $HOME/.local/share/linexin/scripts/wine-affinity-config.sh"
                run_and_log(pacman_cmd, _("Failed to install wine-affinity."))

                # --- 2. Wine Config Script (Interactive) ---
                self.progress_data += _("\nStep 2: Configuring Wine environment...\n")
                self.progress_data += _("This step will run 'winetricks' and may open new windows. Please follow any on-screen instructions.\n")
                self.progress_data += _("The installer will continue automatically after this step is complete.\n\n")
                GLib.idle_add(self.update_output_buffer, self.progress_data)

                config_script_path = os.path.expanduser("~/.local/share/linexin/scripts/wine-affinity-config.sh")
                
                # Run the interactive script, automatically answering "Y" to any initial prompts.
                # This allows the script to run freely and open its own GUI windows.
                config_process = subprocess.Popen(
                    config_script_path, shell=True, stdin=subprocess.PIPE, text=True
                )
                # The communicate() method sends the input, closes stdin, and waits for the process to finish.
                config_process.communicate(input='Y\n')

                if config_process.returncode != 0:
                    raise Exception(_("The Wine configuration script failed with exit code {}.").format(config_process.returncode))

                self.progress_data += _("Wine configuration complete.\n")
                GLib.idle_add(self.update_output_buffer, self.progress_data)
                
                # --- 3. Run Affinity Installer via Wine ---
                self.progress_data += _("\nStep 3: Running the Affinity installer. Please follow the on-screen instructions...\n\n")
                self.progress_data += _("Remember to install .NET if the installer prompts you.\n\n")
                GLib.idle_add(self.update_output_buffer, self.progress_data)
                wine_cmd = f'rum wine-affinity "{os.path.expanduser("~/.WineAffinity")}" wine "{exe_path}"'
                run_and_log(wine_cmd, _("The Affinity installer did not complete successfully."))

                # --- 4. Move Desktop Files ---
                self.progress_data += _("\nStep 4: Creating application shortcuts...\n\n")
                GLib.idle_add(self.update_output_buffer, self.progress_data)
                
                affinity_dir = os.path.expanduser("~/.WineAffinity/drive_c/Program Files/Affinity")
                shortcuts_dir = os.path.expanduser("~/.local/share/linexin/shortcuts")
                applications_dir = os.path.expanduser("~/.local/share/applications")
                folder_desktop_map = {
                    "Photo 2": "photo-2.desktop",
                    "Designer 2": "designer-2.desktop",
                    "Publisher 2": "publisher-2.desktop"
                }

                os.makedirs(applications_dir, exist_ok=True)
                apps_found = False
                for folder, desktop_file in folder_desktop_map.items():
                    if os.path.isdir(os.path.join(affinity_dir, folder)):
                        apps_found = True
                        source_path = os.path.join(shortcuts_dir, desktop_file)
                        dest_path = os.path.join(applications_dir, desktop_file)
                        if os.path.isfile(source_path):
                            shutil.move(source_path, dest_path)
                            log_msg = _("Moved {} to {}\n").format(desktop_file, applications_dir)
                            self.progress_data += log_msg
                            GLib.idle_add(self.update_output_buffer, self.progress_data)
                        else:
                            log_msg = _("Warning: Desktop shortcut {} not found in {}\n").format(desktop_file, shortcuts_dir)
                            self.progress_data += log_msg
                            GLib.idle_add(self.update_output_buffer, self.progress_data)
                
                if not apps_found:
                    self.progress_data += _("Warning: No Affinity application folders found to create shortcuts.\n")
                    GLib.idle_add(self.update_output_buffer, self.progress_data)

            except Exception as e:
                self.error_message = str(e)
                self.progress_data += _("\nError: {}").format(e)
                GLib.idle_add(self.update_output_buffer, self.progress_data)

            GLib.idle_add(self.finish_installation)

        threading.Thread(target=stream_output, daemon=True).start()

    def update_output_buffer(self, text):
        if self.progress_visible:
            self.output_buffer.set_text(text)
            GLib.idle_add(self.scroll_to_end)
        return False

    def scroll_to_end(self):
        end_iter = self.output_buffer.get_end_iter()
        self.output_textview.scroll_to_iter(end_iter, 0.0, False, 0.0, 0.0)
        return False

    def finish_installation(self):
        self.install_started = False
        self.header_bar.set_sensitive(True)
        self.header_bar.set_opacity(1)
        self.btn_install.set_sensitive(True)
        self.btn_toggle_progress.set_sensitive(True)
        
        if self.error_message:
            self.info_label.set_markup(f'<span color="red" weight="bold">{_("Installation failed: {}").format(self.error_message)}</span>')
        else:
            self.info_label.set_markup(f'<span color="green" weight="bold">{_("Successfully installed {}!").format(self.current_product)}</span>')
        
        self.info_label.set_visible(True)
        self.output_frame.set_visible(False)
        self.progress_visible = False
        self.btn_toggle_progress.set_label(_("Show progress"))
        
        return False

class AffinityApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="github.petexy.affinityinstaller")

    def do_activate(self):
        win = MainWindow(self)
        win.present()

if __name__ == "__main__":
    import sys
    app = AffinityApp()
    sys.exit(app.run())